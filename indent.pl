#!/usr/bin/perl

# [注意点]
# C, C++ 対応．perl や Ruby などの正規表現を使用しているコードには使ってはならない．
# '*' はポインタの役割があるのでパス．
# '/' もパスが壊れる可能性があるためパス．
# '$' も変数として使われる可能性があるためパス．

use strict;
use warnings;

while(<>){

	# '=' を抽出(代入演算子以外の'='を抽出)
	$_=~s/([^ \+\-\*\/%&|^!<>=])=([^ <>=~])/$1 = $2/g; # 前後に空白もメタ文字も無い時
	$_=~s/ =([^ <>=~])/ = $1/g; # 前に空白はあるが後ろに空白が無い時
	$_=~s/([^ \+\-\*\/%&|^!<>=])= /$1 = /g; # 前に空白が無くて後ろに空白がある時

	# "==" を抽出
	$_=~s/([^ =])==([^ =])/$1 == $2/g;
	$_=~s/ ==([^ =])/ == $1/g;
	$_=~s/([^ =])== /$1 == /g;

	# "+=" などの代入演算子を抽出
	$_=~s/([^ ])(\+=|\-=|\*=|\/=|%=|&=|\|=|^=|!=)([^ ])/$1 $2 $3/g;
	$_=~s/ (\+=|\-=|\*=|\/=|%=|&=|\|=|^=|!=)([^ ])/ $1 $2/g;
	$_=~s/([^ ])(\+=|\-=|\*=|\/=|%=|&=|\|=|^=|!=) /$1 $2 /g;

	# ">=" の抽出
	$_=~s/([^ <>])(>=|<=)([^ ])/$1 $2 $3/g;
	$_=~s/ (>=|<=)([^ ])/ $1 $2/g;
	$_=~s/([^ <>])(>=|<=) /$1 $2 /g;

	# ">>=" の抽出
	$_=~s/([^ ])(<<=|>>=)([^ ])/$1 $2 $3/g;
	$_=~s/ (<<=|>>=)([^ ])/ $1 $2/g;
	$_=~s/([^ ])(<<=|>>=) /$1 $2 /g;

	# "<<" と ">>" の抽出
	$_=~s/([^ ])(<<|>>)([^ =])/$1 $2 $3/g;
	$_=~s/ (<<|>>)([^ =])/ $1 $2/g;
	$_=~s/([^ ])(<<|>>) /$1 $2 /g;

	# "//" の抽出
	$_=~s/(\S)\/\/(\S)/$1 \/\/ $2/g;
	$_=~s/(\s)\/\/(\S)/$1\/\/ $2/g;
	$_=~s/(\S)\/\/(\s)/$1 \/\/$2/g;
	$_=~s/^\/\/(\S)/\/\/ $1/g;

	# "&&" と "||" の抽出
	$_=~s/([^ ])(&&|\|\|)([^ ])/$1 $2 $3/g;
	$_=~s/ (&&|\|\|)([^ ])/ $1 $2/g;
	$_=~s/([^ ])(&&|\|\|) /$1 $2 /g;


	# ';' の後に文字があるなら半角スペースを挿入(vim ではなぜか\nを指定しないと行末に空白が入る)
	$_=~s/;([^ \n])/; $1/g;

	# ',' 後にスペースを挿入
	$_=~s/,([^ ])/, $1/g;

	# '+' の前後にスペースを挿入
	$_=~s/([^+\s])\+([^+=\s])/$1 + $2/g;
	$_=~s/([^+\s])\+(\s)/$1 +$2/g;
	$_=~s/(\s)\+([^+=\s])/$1+ $2/g;

	# '-' の前後にスペースを挿入
	$_=~s/([^-<\s])\-([^-=>\s])/$1 - $2/g;
	$_=~s/([^-<\s])\-(\s)/$1 -$2/g;
	$_=~s/(\s)\-([^-=>\s])/$1- $2/g;

	print $_;
}

<<COM;
/*======*/ の様な文字列が分解されてしまう．*= の扱いに関してはもう一度考えたほうが良い．
COM
